package config

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/knadh/koanf/parsers/toml"
	"github.com/knadh/koanf/providers/env"
	"github.com/knadh/koanf/providers/file"
	"github.com/knadh/koanf/providers/structs"
	"github.com/knadh/koanf/v2"
)

const (
	DefaultPrefix    = "ZUP-"
	DefaultSuffixPrd = "-prd"
	DefaultSuffixHml = "-hml"
	DefaultColor     = true
)

type Config struct {
	Prefix    string `koanf:"prefix"`
	SuffixPrd string `koanf:"suffix_prd"`
	SuffixHml string `koanf:"suffix_hml"`
	Color     bool   `koanf:"color"`
}

func LoadConfig(configPath string) (*Config, error) {
	k := koanf.New(".")

	// Load default values
	defaultCfg := &Config{
		Prefix:    DefaultPrefix,
		SuffixPrd: DefaultSuffixPrd,
		SuffixHml: DefaultSuffixHml,
		Color:     DefaultColor,
	}

	if err := k.Load(structs.Provider(defaultCfg, "koanf"), nil); err != nil {
		return nil, fmt.Errorf("failed to load default config: %w", err)
	}

	// Load from config file if it exists
	if configPath == "" {
		configPath = GetConfigPath()
	}

	if _, err := os.Stat(configPath); err == nil {
		if err := k.Load(file.Provider(configPath), toml.Parser()); err != nil {
			return nil, fmt.Errorf("failed to load config file %s: %w", configPath, err)
		}
	}

	// Load from environment variables (CHR_PREFIX, CHR_SUFFIX_PRD, etc.)
	if err := k.Load(env.Provider("CHR_", ".", func(s string) string {
		return strings.ToLower(strings.TrimPrefix(s, "CHR_"))
	}), nil); err != nil {
		return nil, fmt.Errorf("failed to load environment variables: %w", err)
	}

	var cfg Config
	if err := k.Unmarshal("", &cfg); err != nil {
		return nil, fmt.Errorf("failed to unmarshal config: %w", err)
	}

	return &cfg, nil
}

func SaveConfig(configPath string, cfg *Config) error {
	if configPath == "" {
		configPath = GetConfigPath()
	}

	// Ensure config directory exists
	configDir := filepath.Dir(configPath)
	if err := os.MkdirAll(configDir, 0755); err != nil {
		return fmt.Errorf("failed to create config directory: %w", err)
	}

	// Create TOML content with comments
	content := fmt.Sprintf(`# Configuration file for chr tool
# Generated by 'chr config' command

# The prefix for branch names (default: "%s")
prefix = "%s"

# The suffix for production branches (default: "%s")
suffix_prd = "%s"

# The suffix for homologation branches (default: "%s")
suffix_hml = "%s"

# Enable colored output (default: %v)
color = %v
`,
		DefaultPrefix, cfg.Prefix,
		DefaultSuffixPrd, cfg.SuffixPrd,
		DefaultSuffixHml, cfg.SuffixHml,
		DefaultColor, cfg.Color,
	)

	if err := os.WriteFile(configPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	return nil
}

func GetConfigPath() string {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return ""
	}
	return filepath.Join(homeDir, ".config", "chr.toml")
}

func (c *Config) Set(key, value string) error {
	switch key {
	case "prefix":
		c.Prefix = value
	case "suffix_prd":
		c.SuffixPrd = value
	case "suffix_hml":
		c.SuffixHml = value
	case "color":
		boolVal, err := strconv.ParseBool(value)
		if err != nil {
			return fmt.Errorf("invalid boolean value for color: %s", value)
		}
		c.Color = boolVal
	default:
		return fmt.Errorf("unknown configuration key: %s", key)
	}
	return nil
}

func (c *Config) Get(key string) (string, error) {
	switch key {
	case "prefix":
		return c.Prefix, nil
	case "suffix_prd":
		return c.SuffixPrd, nil
	case "suffix_hml":
		return c.SuffixHml, nil
	case "color":
		return strconv.FormatBool(c.Color), nil
	default:
		return "", fmt.Errorf("unknown configuration key: %s", key)
	}
}

func (c *Config) String() string {
	return fmt.Sprintf(`Configuration:
  prefix: %s
  suffix_prd: %s
  suffix_hml: %s
  color: %v`, c.Prefix, c.SuffixPrd, c.SuffixHml, c.Color)
}
